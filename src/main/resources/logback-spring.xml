<?xml version="1.0" encoding="utf-8" ?>
<!-- 从高到地低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL -->
<!-- 日志输出规则  根据当前ROOT 级别，日志输出时，级别高于root默认的级别时  会输出 -->
<!-- 以下  每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志-->
<!-- 属性描述 scan：性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，
默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->
<configuration scan="true" scanPeriod="60 seconds" debug="false">

    <!--<include resource="org/springframework/boot/logging/logback/base.xml"/>-->
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
    <!--<property name="LOG_FILE" value="${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}}/spring.log}"/>-->
    <include resource="org/springframework/boot/logging/logback/console-appender.xml"/>

    <!-- 全局统一 pattern -->
    <property name="LOG_PATTERN"
              value="%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}}|${PID:- }|%level|${LOG_LEVEL_PATTERN:-%5p}|%t|%-40.40logger{39}: %msg%n"/>

    <property name="log.pattern" value="%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n"/>
    <!-- 定义日志文件 输入位置 application.properties -->
    <property name="log.path" value="${logging.file.path}"/>
    <!-- 正确 此 LOG_HOME 配置生效 -->
    <!--<property name="LOG_HOME" value="${user.home}/logs"/>-->
    <!--    <property name="logPath" value="d:/test_log" />-->
    <!--日志文件名称：这里spring.application.name表示工程名称-->
    <springProperty scope="context" name="APP_NAME" source="spring.application.name"/>

    <!--1、在springboot项目中使用logback记录日志，在logback.xml中配置日志存储位置时读取application.properties中配置的路径，在 logback.xml中配置引用如下：<property name="log.path" value="${path.log}"/>
    发现读取不到
    2、原因：因为logback.xml的加载顺序早于springboot的application.yml (或application.properties) 配置文件当然读不到application.yml（或application.properties）文件中的值了
    3、解决方案：需要通过springProperty标签来引用：<springProperty scope="context" name="log.path" source="path.log"/>
    这里的name和上面property标签一样不多说，source其实就是上面的value啦，只不过要注意：千万不要加${}
    如果还是读取不到，请把你的logback.xml配置文件名，改为：logback-spring.xml就可以了。 -->
    <!--    2、原因：因为logback.xml的加载顺序早于springboot的application.yml (或application.properties) 配置文件当然读不到application.yml（或application.properties）文件中的值了-->
    <!--    3、解决方案：需要通过springProperty标签来引用：<springProperty scope="context" name="log.path" source="path.log"/>-->
    <!-- 正确 此配置读取 application.properties 中的配置 生效-->
    <springProperty scope="context" name="LOG_HOME" source="logging.file.path"/>
    <!-- 日志最大的历史 30天 -->
    <property name="maxHistory" value="3"/>
    <property name="errorMaxHistory" value="10"/>

    <!--<springProperty scope="context" name="LOGSTASH_URL" source="logstash.url"-->
    <!--                defaultValue="localhost:4560"/>-->

    <!-- 配置项， 通过此节点配置日志输出位置（控制台、文件、数据库）、输出格式等-->
    <!-- ConsoleAppender代表输出到控制台 -->
    <appender name="CONSOLE_LOG" class="ch.qos.logback.core.ConsoleAppender">
        <!-- layout代表输出格式 -->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <!--<pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger -%msg%n</pattern>-->
            <pattern>${LOG_PATTERN}</pattern>
        </layout>
    </appender>
    <!-- 日志输出文件 -->
    <appender name="INFO_LOG" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger -%msg%n</pattern>
        </encoder>

        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!-- daily rollover ERROR in ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP@648c94da - Missing integer token, that is %i,
             in FileNamePattern [C:\Users\sam/logs/info/%d{yyyyMMdd}/spring-boot-learning.log] -->
            <!-- SizeAndTimeBasedRollingPolicy 和 .%i.log 配合使用 <fileNamePattern>${LOG_HOME}/info/%d{yyyyMMdd}/${APP_NAME}.%i.log</fileNamePattern> -->
            <fileNamePattern>${LOG_HOME}/info/%d{yyyyMMdd}/${APP_NAME}.%i.log</fileNamePattern>
            <maxHistory>${maxHistory}</maxHistory>
            <maxFileSize>100MB</maxFileSize>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <!-- 此日志文件只记录info级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <!-- 如果命中就禁止这条日志 -->
            <onMatch>DENY</onMatch>
            <!-- 如果没有命中就使用这条规则 -->
            <onMismatch>ACCEPT</onMismatch>
        </filter>

        <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender-->
        <!-- 滚动策略，它根据时间来制定滚动策略.既负责滚动也负责触发滚动 -->
        <!-- <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">-->
        <!--    <fileNamePattern>${LOG_HOME}/info/%d{yyyyMMdd}/${APP_NAME}.log</fileNamePattern>-->
        <!--    &lt;!&ndash; 输出路径 &ndash;&gt;-->
        <!--    &lt;!&ndash;            <fileNamePattern>${logging.file.path}/info/%d.log</fileNamePattern>&ndash;&gt;-->
        <!--    &lt;!&ndash;            <fileNamePattern>${log.path}/info/%d.log</fileNamePattern>&ndash;&gt;-->
        <!--    &lt;!&ndash; 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件假设设置每个月滚动，且<maxHistory>是6，-->
        <!--    则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除&ndash;&gt;-->
        <!--    <maxHistory>${maxHistory}</maxHistory>-->
        <!--</rollingPolicy>-->
        <!-- 只是超过10m就生成一个新文件-->
        <!--<triggeringPolicy-->
        <!--        class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">-->
        <!--    <MaxFileSize>100MB</MaxFileSize>-->
        <!--</triggeringPolicy>-->

        <!-- 按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志。
        <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
          <fileNamePattern>${logPath}/%d{yyyy-MM-dd}/.log.zip</fileNamePattern>
          <minIndex>1</minIndex>
          <maxIndex>3</maxIndex>
        </rollingPolicy>   -->
        <!-- 查看当前活动文件的大小，如果超过指定大小会告知RollingFileAppender 触发当前活动文件滚动
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <maxFileSize>5MB</maxFileSize>
        </triggeringPolicy>   -->
    </appender>

    <!-- 输出到logstash-->
    <!--<appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">-->
    <!--    <destination>${LOGSTASH_URL}</destination>-->
    <!--    <encoder charset="UTF-8" class="net.logstash.logback.encoder.LogstashEncoder"/>-->
    <!--</appender>-->


    <appender name="ASYNC_INFO_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
        <queueSize>256</queueSize>
        <!-- 添加附加的appender,最多只能添加一个 -->
        <appender-ref ref="INFO_LOG"/>
    </appender>



    <!-- 特殊记录Error日志 -->
    <appender name="ERROR_LOG" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 只记录ERROR级别日志，添加范围过滤，可以将该类型的日志特殊记录到某个位置 -->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
        <encoder>
            <!-- 格式化输出: %d: 日期; %-5level: 级别从左显示5个字符宽度; %thread: 线程名; %logger: 类名; %M: 方法名; %line: 行号; %msg: 日志消息; %n: 换行符 -->
            <!-- 2019-12-01 00:00:00.000|pid|log-level|[svc-name,trace-id,span-id,user-id,biz-id]|thread-name|package-name.class-name : log message -->
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger -%msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--<fileNamePattern>${logPath}/error/%d.log</fileNamePattern>-->
            <fileNamePattern>${LOG_HOME}/error/%d{yyyyMMdd}/${APP_NAME}.log</fileNamePattern>
            <!-- 日志最大的历史 60天 -->
            <maxHistory>${errorMaxHistory}</maxHistory>
        </rollingPolicy>
        <!--<rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">-->
        <!--    <fileNamePattern>${LOG_FILE}.%i</fileNamePattern>-->
        <!--</rollingPolicy>-->
        <!-- 只是超过10m就生成一个新文件-->
        <triggeringPolicy
                class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <MaxFileSize>100MB</MaxFileSize>
        </triggeringPolicy>


        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <appender name="ASYNC_ERROR_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
        <queueSize>256</queueSize>
        <!-- 添加附加的appender,最多只能添加一个 -->
        <appender-ref ref="ERROR_LOG"/>
    </appender>

    <appender name="DEBUG_LOG" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/debug/%d{yyyyMMdd}/${APP_NAME}.log</fileNamePattern>
            <MaxHistory>${maxHistory}</MaxHistory>
        </rollingPolicy>
        <encoder>
            <!-- 格式化输出: %d: 日期; %-5level: 级别从左显示5个字符宽度; %thread: 线程名; %logger: 类名; %M: 方法名; %line: 行号; %msg: 日志消息; %n: 换行符 -->
            <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] [%thread] [%logger{50}] [%M] [%line] - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>DEBUG</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
    <!-- 根节点，表名基本的日志级别，里面可以由多个appender规则 -->
    <!-- level="info"代表基础日志级别为info -->
    <root level="info">
        <!-- 引入控制台输出规则 -->
        <appender-ref ref="CONSOLE_LOG"/>
        <appender-ref ref="INFO_LOG"/>
        <appender-ref ref="ERROR_LOG"/>
        <!-- 输出相关包下面的日志 -->
    </root>

    <springProfile name="dev, test, pre">
        <!-- 输出相关包下面的日志 -->
        <logger name="com.ms.springboot.learning.mapper" level="DEBUG">
        </logger>
        <!-- 在这边配置成true的话，也就是默认的情况，这时候当前Logger会继承父Logger的Appender，说白了就是当前日志的输出除了输出在当前日志文件以外，还会输出至父文件里。
        所以一般情况下，我们为了避免重复打印，会将这个参数设置成false，以减少不必要的输出。-->
        <logger name="com.ms.springboot.learning.service" level="error" additivity="false">
        </logger>
    </springProfile>
    <!--<springProfile name="local, prod">-->
    <!--    &lt;!&ndash;<root level="error">&ndash;&gt;-->
    <!--        &lt;!&ndash;<appender-ref ref="LOGSTASH"/>&ndash;&gt;-->
    <!--    &lt;!&ndash;</root>&ndash;&gt;-->
    <!--    <logger name="com.ms.springboot.learning" level="error">-->
    <!--    </logger>-->
    <!--</springProfile>-->

    <springProfile name="local, prod">

        <root level="error">
            <appender-ref ref="CONSOLE_LOG"/>
        </root>
        <!--<root level="error">-->
        <!--<appender-ref ref="LOGSTASH"/>-->
        <!--</root>-->
        <logger name="com.*" level="error"></logger>
        <logger name="org.springframework.*" level="info"></logger>
        <logger name="com.ms.springboot.learning" level="info">
        </logger>
        <logger name="com.ms.springboot.learning.*" level="error">
        </logger>
    </springProfile>
</configuration>